#!/usr/bin/env python3.5

import sys

sys.path.insert(0, './pyyaml/lib3/')

import yaml, glob, collections

config_paths = glob.glob('./configs/*')

def p(s):
  print(s, end="", file=sys.stderr, flush=True)

def print_collection(l):
  c = collections.Counter(l)
  for name, count in c.most_common():
    print('{0: <5} {1}'.format(count, name))

p('parsing {} configs'.format(len(config_paths)))

objects = {}
bad = []

for path in config_paths:
  with open(path, 'r') as f:
    try:
      o = yaml.safe_load(f.read())
    except (yaml.scanner.ScannerError, yaml.parser.ParserError):
      bad.append(path)
      p('x')
      continue
    p('.')
    objects[path] = o
p('\n')
p('\n')

bad = []
p('checking for lists')
for path in objects:
  o = objects[path]
  if not isinstance(o, list):
    bad.append(path)
    p('x')
    continue
  p('.')
p('\n')
p('\n')

for path in bad:
  del objects[path]

p('checking for dicts')
for path in objects:
  o = objects[path]
  for task in o:
    if not isinstance(task, dict):
      p('x')
      continue
    p('.')
p('\n')
p('\n')

names = []
expected = 'link clean shell aliases meta'.split()
unexpected = []
for path in objects:
  o = objects[path]
  for task in o:
    for key in task:
      if key not in expected and not key.startswith('~'):
        unexpected.append(key)
        p('unexpected key: {} in {}\n'.format(key, path))
      names.append(key)

print('tasks:')
print_collection(names)

shell_commands = []
for path in objects:
  o = objects[path]
  for task in o:
    for key in task:
      if key == 'shell':
        cmds = task[key]
        for cmd in cmds:
          if isinstance(cmd, str):
            shell_commands.append(cmd)
          elif isinstance(cmd, list):
            if len(cmd) == 0:
              pass
            else:
              shell_commands.append(cmd[0])
print()

print('shell commands:')
print_collection(shell_commands)
